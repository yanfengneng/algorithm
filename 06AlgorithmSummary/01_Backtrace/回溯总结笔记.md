重点参考：[一文搞懂回溯算法](https://blog.csdn.net/qq_36963950/article/details/115428826)、[【算法刷题】回溯算法题型及方法归纳](https://blog.csdn.net/qq_41094332/article/details/128741217)、[最全总结！一篇文章带你学会回溯算法](https://blog.csdn.net/Sloent/article/details/135309999)

补充：[一文弄懂回溯算法（例题详解）](https://blog.csdn.net/2302_79862386/article/details/136418692)、[回溯算法总结1](https://blog.csdn.net/PETERPARKERRR/article/details/121399628)、[回溯算法总结2](https://blog.csdn.net/ggggggzzzzz/article/details/132546654)

# 一、回溯法

## 1.1 基本概念

回溯法本质上是一种暴力穷举法，与 DFS 的区别在于：**DFS 是用来遍历「节点」的，而回溯法就用来遍历「树枝」的**。

**抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点都存放着一个合法答案。将整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。**

~~站在回溯树的一个节点上，需要思考三个问题？~~

* ~~1）路径：也就是当前已经做出的选择。~~
* ~~2）选择列表：也就是当前可以做的选择。~~
* ~~3）结束条件：也就是到达决策树的底层，无法再做出选择的条件。~~

>https://zhuanlan.zhihu.com/p/356947604

**使用编程实现回溯法的步骤：**

* 1）画出**递归树**，然后思考**当前节点是如何进行到下一层节点的**，也就是**选择列表是如何变化的**，如何**使用参数来表示选择列表的变化**。
* 2）**找判断条件：**判断此时的路径是否可以作为结果。
* 3）**找选择列表：**找准路径选择列表，思考**如何使用状态/参数值来表示当前层的选择列表**。
* 4）**是否剪枝：**判断是否需要剪枝（是否所有答案都满足题目要求，是则无需剪枝，不是则确定剪枝条件）。
* 5）**做出选择并递归：**（for循环中）从路径选择列表里做出选择，**调用递归函数，进入下一层**。
* 6）**撤销选择：**从下层函数返回后，撤销这次的路径选择，**以便开始同一层的其他选择**。

```cpp
/* https://www.zhihu.com/question/325665309/answer/2245817776 */
vector<bool> visitied;			// 排列问题时，使用 visited 判定是否访问过
vector<type> path;				// 存储某一条路径的情况
vector<vector<type>> result;		// 结果集
// 对于回溯函数的参数：由于回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
void backtrack(参数: 路径, 选择列表) {
    if (终止条件) {
        result.add(path);
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        1. 处理节点;
        // 新的选择列表 = 将该选择从选择列表中移除
        // 路径.add(选择)
        
        // 使用新的选择列表递归到下一层
        2. backtrack(路径，新的选择列表); // 递归
        
        3. 回溯，撤销处理结果
        // 撤销当前层的当前选择，进行当前层的下一个选择
        // 路径.remove(选择)
        // 原先的选择列表 = 再将该选择加入选择列表
    }
}
```

## 1.2 应用题型

**组合性问题**：

- 组合问题：N个数里面按一定规则找出k个数的集合。
- 分割问题：一个字符串按一定规则有几种切割方式。
- 子集问题：一个N个数的集合里有多少符合条件的子集。

**排列性问题**：

- 排列问题：N个数按一定规则全排列，有几种排列方式。
- 棋盘问题：N皇后，解数独等等。

**注：组合问题并不要求元素按一定顺序，排列问题要求元素按一定顺序。**

如何区分该问题是组合问题还是排序问题？

* <font color=alice>若求解该问题，不需要强调元素顺序，就是组合问题；需要强调元素顺序，就是排列问题。</font>

***

**去重方式：**

* 1）**有序数组去重**：采用 `i > startIndex && nums[i] == nums[i - 1]` 来去重。
* 2）**无序数组去重**：1. 对于不需要保留原序列顺序的，采用**无序变有序，再按有序方式去重**；2. 对于要求保留原序列顺序的，**使用对树层去重，每遍历到一层时，就新设置一个 `hashmap`，用于记录是否访问过某一元素**。