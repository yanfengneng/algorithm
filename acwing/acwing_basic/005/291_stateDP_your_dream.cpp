#include <bits/stdc++.h>
using namespace std;

using LL = long long;
const int N = 12, M = 1 << N;
// 总方案数其实就是横着放的小方块的合法方案数（当前摆放完横着的小方块后，可以用竖着的小方块将其塞满，那么这样的方案数就是合法的）
// f[i][j]表示已经将i-1列摆好了，并且从第i-1列伸到第i列的状态是j的方案数
LL f[N][M];
// 存储从k到j的所有合法状态k，这样避免每次都去循环一遍j k再进行判断浪费时间
vector<int> state[M];
// 判断当前这一列是否能由1x2的小方块填满，当前这一列所有连续空着的位置是否为偶数
bool st[M];
int n,m;

int main()
{
    while(cin>>n>>m,n||m)
    {
        // 先来预处理下st数组，表示每个状态连续的0是否为偶数个
        for(int i=0;i<1<<n;++i)
        {
            // cnt用来表示0的个数
            int cnt=0;
            // 表示是否合法
            bool valid=true;
            // 横着做的话，每行就会有n个数
            for(int j=0;j<n;++j)
                if(i>>j&1)// i的第j位为1
                {
                    if(cnt&1)// 若有连续奇数个0的话，则表示不合法
                    {
                        valid=false;
                        break;
                    }
                    // 同时将cnt进行清空，因为cnt只用来统计连续的0，遇到1了就需要进行重新计数了
                    cnt=0;
                }
                else cnt++;

            // 若最后一段也为奇数的话，也要置为false
            if(cnt&1)valid=false;
            st[i]=valid;
        }

        // 预处理进行转移的每个状态，即由k->j的合法状态k，这样在进行状态转移的时候，就不需要每次都去循环一次j和k进行判断了
        // 第i-2列伸到第i-1列的状态为j；第i-1列伸到第i列的状态为k
        for(int j=0;j<1<<n;++j)
        {
            state[j].clear();
            /* 
            由k推到j的话，需要两个条件：
                1、j和k不能在同一行，否则会发成碰撞（首尾碰撞）
                2、所有连续空着的位置的长度必须为偶数
            */  
            for(int k=0;k<1<<n;++k)
                // k 表示第i-1列的状态数，第i-1列空余的位置的长度必须为偶数，j|k表示第i-1列和第i列相应位置都是1，这样其实就是第i-1列被塞满的长度了
                if((j&k)==0&&st[j|k])
                    state[j].push_back(k);
        }

        memset(f,0,sizeof f);
        // 表示空棋盘有一种方案
        f[0][0]=1;
        // 开始进行状态转移
        for(int i=1;i<=m;++i)
            for(int j=0;j<1<<n;++j)
                // 由于第i-1列到第i列的小方块的摆放已经是固定的了，即j是固定的了，所在在集合划分的时第i-2列到第i-1列的方案是变化的，即k是变化的，子集k的方案和等于j
                for(auto k:state[j])
                    f[i][j]+=f[i-1][k];
        
        // f[m][0]表示前m-1列已经摆好了，下标从0开始，也就是整个棋盘已经摆好了；并且从第m-1列延伸到第m列的状态为0，表示没有任何一个方块延伸出来，最后恰好是这个棋盘的所有方案数
        cout<<f[m][0]<<endl;
    }
    return 0;
}