01背包和完全背包 问题的状态都是二维的，即f[i][j]：
* i 表示从前 i 个物品中选
* j 表示体积，有两种定义，第一种是体积不超过j；第二种是体积刚好为j，这两种表示对应的状态f[i][j]的初始值不同而已
```cpp
// 这俩种初始值应设为无效值，与题目要求的结果有关，题目说明无效值为0，那就初始化为0；否则就初始化为无穷
// 体积不超过 j，则f[i][j]的初始值全部为0
f[N][N]={0,0...,0};

// 体积刚好为 j，则f[i][j]的初始值全部为无穷，表示初始时为无效值
f[N][N]={INF,INF...,INF};
```
恰好装满 VS 可以不装满 恰好装满。只需要初始化 dp[0] 为 0， 其他初始化为 -Infinity 即可,(因为是无解)。 可以不装满。 只需要全部初始化为 0，即可 (因为不选是可行的)

>注意点：
>* <font color=blue>完全背包求组合数时，外层 for 循环先遍历物品，内层 for 循环再遍历背包体积，这样可保证组合数唯一。因为先遍历物品，其实就是限制物品的种类是`[1,i]`，在此基础上上去考虑不同的背包容量，其实这里物品的选择顺序就已经固定了，比如物品1、物品3、物品5。</font>二维状态 dp 数组是一行一行的进行更新的。
>* <font color=alice>完全背包求排列数时，外层 for 循环先遍历背包体积，内层 for 循环再遍历物品，这样可保证所有物品的相对顺序不同，保证排列唯一。先遍历背包，其实就是限定了背包的体积，物品不限定，每次内层循环时会把每种物品都考虑在内，所以它的相对顺序会发生变化。</font>二维状态 dp 数组是一列一列的进行更新的。